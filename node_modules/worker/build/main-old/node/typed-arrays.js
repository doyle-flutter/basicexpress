let shmmap = {
	create() {
		throw new Error('cannot use shared memory on this platform');
	},
};
try {
	shmmap = require('shmmap');
}
catch(e_require) {}


const sharing = require('./sharing.js');
const TypedArray = Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array(0))).constructor;



class Int8ArrayS extends Int8Array {
	constructor(z_arg_0, nb_offset, nl_array) {
		// this
		let h_this = {};

		// self
		let at_self;


		// length constructor
		if('number' === typeof z_arg_0) {
		// create shared memory segment
			let [s_key, db_shared] = shmmap.create(z_arg_0);
			h_this.key = s_key;
			at_self = new Int8Array(db_shared.buffer);
		}
		// typed array constructor
		else if(z_arg_0 instanceof TypedArray) {
			// transferable typed array
			if(sharing(z_arg_0)) {
				debugger;
			}
			// basic typed array
			else {
		// create shared memory segment
				let [s_key, db_shared] = shmmap.create(z_arg_0.byteLength);
				h_this.key = s_key;
				at_self = new Int8Array(db_shared.buffer);


				// copy data over
				at_self.set(z_arg_0);
			}
		}
		// array buffer constructor
		else if(z_arg_0 instanceof ArrayBuffer) {
			// force offset
			nb_offset = nb_offset || 0;

			// no length; deduce it from offset
			if('undefined' === typeof nl_array) {
				nl_array = z_arg_0.length - nb_offset;
			}

			// array size in bytes
			let nb_array = nl_array;

			// create shared memory segment
			let dsb = shmmap.create(nb_array);

			// create typed array
			at_self = new Int8Array(dsb, 0, nb_array);

			// create copy src
			let at_src = new Int8Array(z_arg_0, nb_offset, nl_array);

			// copy data over
			at_self.set(at_src);
		}

		// create self
		super(at_self);

		// save fields
		Object.assign(this, h_this);
	}

	base(...a_args) {
		return new Int8Array(...a_args);
	}
}

// static field
Object.assign(Int8ArrayS.prototype, {
	[sharing.$_SHAREABLE]: 1,
});
class Uint8ArrayS extends Uint8Array {
	constructor(z_arg_0, nb_offset, nl_array) {
		// this
		let h_this = {};

		// self
		let at_self;


		// length constructor
		if('number' === typeof z_arg_0) {
		// create shared memory segment
			let [s_key, db_shared] = shmmap.create(z_arg_0);
			h_this.key = s_key;
			at_self = new Uint8Array(db_shared.buffer);
		}
		// typed array constructor
		else if(z_arg_0 instanceof TypedArray) {
			// transferable typed array
			if(sharing(z_arg_0)) {
				debugger;
			}
			// basic typed array
			else {
		// create shared memory segment
				let [s_key, db_shared] = shmmap.create(z_arg_0.byteLength);
				h_this.key = s_key;
				at_self = new Uint8Array(db_shared.buffer);


				// copy data over
				at_self.set(z_arg_0);
			}
		}
		// array buffer constructor
		else if(z_arg_0 instanceof ArrayBuffer) {
			// force offset
			nb_offset = nb_offset || 0;

			// no length; deduce it from offset
			if('undefined' === typeof nl_array) {
				nl_array = z_arg_0.length - nb_offset;
			}

			// array size in bytes
			let nb_array = nl_array;

			// create shared memory segment
			let dsb = shmmap.create(nb_array);

			// create typed array
			at_self = new Uint8Array(dsb, 0, nb_array);

			// create copy src
			let at_src = new Uint8Array(z_arg_0, nb_offset, nl_array);

			// copy data over
			at_self.set(at_src);
		}

		// create self
		super(at_self);

		// save fields
		Object.assign(this, h_this);
	}

	base(...a_args) {
		return new Uint8Array(...a_args);
	}
}

// static field
Object.assign(Uint8ArrayS.prototype, {
	[sharing.$_SHAREABLE]: 1,
});
class Uint8ClampedArrayS extends Uint8ClampedArray {
	constructor(z_arg_0, nb_offset, nl_array) {
		// this
		let h_this = {};

		// self
		let at_self;


		// length constructor
		if('number' === typeof z_arg_0) {
		// create shared memory segment
			let [s_key, db_shared] = shmmap.create(z_arg_0);
			h_this.key = s_key;
			at_self = new Uint8ClampedArray(db_shared.buffer);
		}
		// typed array constructor
		else if(z_arg_0 instanceof TypedArray) {
			// transferable typed array
			if(sharing(z_arg_0)) {
				debugger;
			}
			// basic typed array
			else {
		// create shared memory segment
				let [s_key, db_shared] = shmmap.create(z_arg_0.byteLength);
				h_this.key = s_key;
				at_self = new Uint8ClampedArray(db_shared.buffer);


				// copy data over
				at_self.set(z_arg_0);
			}
		}
		// array buffer constructor
		else if(z_arg_0 instanceof ArrayBuffer) {
			// force offset
			nb_offset = nb_offset || 0;

			// no length; deduce it from offset
			if('undefined' === typeof nl_array) {
				nl_array = z_arg_0.length - nb_offset;
			}

			// array size in bytes
			let nb_array = nl_array;

			// create shared memory segment
			let dsb = shmmap.create(nb_array);

			// create typed array
			at_self = new Uint8ClampedArray(dsb, 0, nb_array);

			// create copy src
			let at_src = new Uint8ClampedArray(z_arg_0, nb_offset, nl_array);

			// copy data over
			at_self.set(at_src);
		}

		// create self
		super(at_self);

		// save fields
		Object.assign(this, h_this);
	}

	base(...a_args) {
		return new Uint8ClampedArray(...a_args);
	}
}

// static field
Object.assign(Uint8ClampedArrayS.prototype, {
	[sharing.$_SHAREABLE]: 1,
});
class Int16ArrayS extends Int16Array {
	constructor(z_arg_0, nb_offset, nl_array) {
		// this
		let h_this = {};

		// self
		let at_self;


		// length constructor
		if('number' === typeof z_arg_0) {
		// create shared memory segment
			let [s_key, db_shared] = shmmap.create(z_arg_0 << 1);
			h_this.key = s_key;
			at_self = new Int16Array(db_shared.buffer);
		}
		// typed array constructor
		else if(z_arg_0 instanceof TypedArray) {
			// transferable typed array
			if(sharing(z_arg_0)) {
				debugger;
			}
			// basic typed array
			else {
		// create shared memory segment
				let [s_key, db_shared] = shmmap.create(z_arg_0.byteLength);
				h_this.key = s_key;
				at_self = new Int16Array(db_shared.buffer);


				// copy data over
				at_self.set(z_arg_0);
			}
		}
		// array buffer constructor
		else if(z_arg_0 instanceof ArrayBuffer) {
			// force offset
			nb_offset = nb_offset || 0;

			// no length; deduce it from offset
			if('undefined' === typeof nl_array) {
				nl_array = z_arg_0.length - nb_offset;
			}

			// array size in bytes
			let nb_array = nl_array << 1;

			// create shared memory segment
			let dsb = shmmap.create(nb_array);

			// create typed array
			at_self = new Int16Array(dsb, 0, nb_array);

			// create copy src
			let at_src = new Int16Array(z_arg_0, nb_offset, nl_array);

			// copy data over
			at_self.set(at_src);
		}

		// create self
		super(at_self);

		// save fields
		Object.assign(this, h_this);
	}

	base(...a_args) {
		return new Int16Array(...a_args);
	}
}

// static field
Object.assign(Int16ArrayS.prototype, {
	[sharing.$_SHAREABLE]: 1,
});
class Uint16ArrayS extends Uint16Array {
	constructor(z_arg_0, nb_offset, nl_array) {
		// this
		let h_this = {};

		// self
		let at_self;


		// length constructor
		if('number' === typeof z_arg_0) {
		// create shared memory segment
			let [s_key, db_shared] = shmmap.create(z_arg_0 << 1);
			h_this.key = s_key;
			at_self = new Uint16Array(db_shared.buffer);
		}
		// typed array constructor
		else if(z_arg_0 instanceof TypedArray) {
			// transferable typed array
			if(sharing(z_arg_0)) {
				debugger;
			}
			// basic typed array
			else {
		// create shared memory segment
				let [s_key, db_shared] = shmmap.create(z_arg_0.byteLength);
				h_this.key = s_key;
				at_self = new Uint16Array(db_shared.buffer);


				// copy data over
				at_self.set(z_arg_0);
			}
		}
		// array buffer constructor
		else if(z_arg_0 instanceof ArrayBuffer) {
			// force offset
			nb_offset = nb_offset || 0;

			// no length; deduce it from offset
			if('undefined' === typeof nl_array) {
				nl_array = z_arg_0.length - nb_offset;
			}

			// array size in bytes
			let nb_array = nl_array << 1;

			// create shared memory segment
			let dsb = shmmap.create(nb_array);

			// create typed array
			at_self = new Uint16Array(dsb, 0, nb_array);

			// create copy src
			let at_src = new Uint16Array(z_arg_0, nb_offset, nl_array);

			// copy data over
			at_self.set(at_src);
		}

		// create self
		super(at_self);

		// save fields
		Object.assign(this, h_this);
	}

	base(...a_args) {
		return new Uint16Array(...a_args);
	}
}

// static field
Object.assign(Uint16ArrayS.prototype, {
	[sharing.$_SHAREABLE]: 1,
});
class Int32ArrayS extends Int32Array {
	constructor(z_arg_0, nb_offset, nl_array) {
		// this
		let h_this = {};

		// self
		let at_self;


		// length constructor
		if('number' === typeof z_arg_0) {
		// create shared memory segment
			let [s_key, db_shared] = shmmap.create(z_arg_0 << 2);
			h_this.key = s_key;
			at_self = new Int32Array(db_shared.buffer);
		}
		// typed array constructor
		else if(z_arg_0 instanceof TypedArray) {
			// transferable typed array
			if(sharing(z_arg_0)) {
				debugger;
			}
			// basic typed array
			else {
		// create shared memory segment
				let [s_key, db_shared] = shmmap.create(z_arg_0.byteLength);
				h_this.key = s_key;
				at_self = new Int32Array(db_shared.buffer);


				// copy data over
				at_self.set(z_arg_0);
			}
		}
		// array buffer constructor
		else if(z_arg_0 instanceof ArrayBuffer) {
			// force offset
			nb_offset = nb_offset || 0;

			// no length; deduce it from offset
			if('undefined' === typeof nl_array) {
				nl_array = z_arg_0.length - nb_offset;
			}

			// array size in bytes
			let nb_array = nl_array << 2;

			// create shared memory segment
			let dsb = shmmap.create(nb_array);

			// create typed array
			at_self = new Int32Array(dsb, 0, nb_array);

			// create copy src
			let at_src = new Int32Array(z_arg_0, nb_offset, nl_array);

			// copy data over
			at_self.set(at_src);
		}

		// create self
		super(at_self);

		// save fields
		Object.assign(this, h_this);
	}

	base(...a_args) {
		return new Int32Array(...a_args);
	}
}

// static field
Object.assign(Int32ArrayS.prototype, {
	[sharing.$_SHAREABLE]: 1,
});
class Uint32ArrayS extends Uint32Array {
	constructor(z_arg_0, nb_offset, nl_array) {
		// this
		let h_this = {};

		// self
		let at_self;


		// length constructor
		if('number' === typeof z_arg_0) {
		// create shared memory segment
			let [s_key, db_shared] = shmmap.create(z_arg_0 << 2);
			h_this.key = s_key;
			at_self = new Uint32Array(db_shared.buffer);
		}
		// typed array constructor
		else if(z_arg_0 instanceof TypedArray) {
			// transferable typed array
			if(sharing(z_arg_0)) {
				debugger;
			}
			// basic typed array
			else {
		// create shared memory segment
				let [s_key, db_shared] = shmmap.create(z_arg_0.byteLength);
				h_this.key = s_key;
				at_self = new Uint32Array(db_shared.buffer);


				// copy data over
				at_self.set(z_arg_0);
			}
		}
		// array buffer constructor
		else if(z_arg_0 instanceof ArrayBuffer) {
			// force offset
			nb_offset = nb_offset || 0;

			// no length; deduce it from offset
			if('undefined' === typeof nl_array) {
				nl_array = z_arg_0.length - nb_offset;
			}

			// array size in bytes
			let nb_array = nl_array << 2;

			// create shared memory segment
			let dsb = shmmap.create(nb_array);

			// create typed array
			at_self = new Uint32Array(dsb, 0, nb_array);

			// create copy src
			let at_src = new Uint32Array(z_arg_0, nb_offset, nl_array);

			// copy data over
			at_self.set(at_src);
		}

		// create self
		super(at_self);

		// save fields
		Object.assign(this, h_this);
	}

	base(...a_args) {
		return new Uint32Array(...a_args);
	}
}

// static field
Object.assign(Uint32ArrayS.prototype, {
	[sharing.$_SHAREABLE]: 1,
});
class Float32ArrayS extends Float32Array {
	constructor(z_arg_0, nb_offset, nl_array) {
		// this
		let h_this = {};

		// self
		let at_self;


		// length constructor
		if('number' === typeof z_arg_0) {
		// create shared memory segment
			let [s_key, db_shared] = shmmap.create(z_arg_0 << 2);
			h_this.key = s_key;
			at_self = new Float32Array(db_shared.buffer);
		}
		// typed array constructor
		else if(z_arg_0 instanceof TypedArray) {
			// transferable typed array
			if(sharing(z_arg_0)) {
				debugger;
			}
			// basic typed array
			else {
		// create shared memory segment
				let [s_key, db_shared] = shmmap.create(z_arg_0.byteLength);
				h_this.key = s_key;
				at_self = new Float32Array(db_shared.buffer);


				// copy data over
				at_self.set(z_arg_0);
			}
		}
		// array buffer constructor
		else if(z_arg_0 instanceof ArrayBuffer) {
			// force offset
			nb_offset = nb_offset || 0;

			// no length; deduce it from offset
			if('undefined' === typeof nl_array) {
				nl_array = z_arg_0.length - nb_offset;
			}

			// array size in bytes
			let nb_array = nl_array << 2;

			// create shared memory segment
			let dsb = shmmap.create(nb_array);

			// create typed array
			at_self = new Float32Array(dsb, 0, nb_array);

			// create copy src
			let at_src = new Float32Array(z_arg_0, nb_offset, nl_array);

			// copy data over
			at_self.set(at_src);
		}

		// create self
		super(at_self);

		// save fields
		Object.assign(this, h_this);
	}

	base(...a_args) {
		return new Float32Array(...a_args);
	}
}

// static field
Object.assign(Float32ArrayS.prototype, {
	[sharing.$_SHAREABLE]: 1,
});
class Float64ArrayS extends Float64Array {
	constructor(z_arg_0, nb_offset, nl_array) {
		// this
		let h_this = {};

		// self
		let at_self;


		// length constructor
		if('number' === typeof z_arg_0) {
		// create shared memory segment
			let [s_key, db_shared] = shmmap.create(z_arg_0 << 4);
			h_this.key = s_key;
			at_self = new Float64Array(db_shared.buffer);
		}
		// typed array constructor
		else if(z_arg_0 instanceof TypedArray) {
			// transferable typed array
			if(sharing(z_arg_0)) {
				debugger;
			}
			// basic typed array
			else {
		// create shared memory segment
				let [s_key, db_shared] = shmmap.create(z_arg_0.byteLength);
				h_this.key = s_key;
				at_self = new Float64Array(db_shared.buffer);


				// copy data over
				at_self.set(z_arg_0);
			}
		}
		// array buffer constructor
		else if(z_arg_0 instanceof ArrayBuffer) {
			// force offset
			nb_offset = nb_offset || 0;

			// no length; deduce it from offset
			if('undefined' === typeof nl_array) {
				nl_array = z_arg_0.length - nb_offset;
			}

			// array size in bytes
			let nb_array = nl_array << 4;

			// create shared memory segment
			let dsb = shmmap.create(nb_array);

			// create typed array
			at_self = new Float64Array(dsb, 0, nb_array);

			// create copy src
			let at_src = new Float64Array(z_arg_0, nb_offset, nl_array);

			// copy data over
			at_self.set(at_src);
		}

		// create self
		super(at_self);

		// save fields
		Object.assign(this, h_this);
	}

	base(...a_args) {
		return new Float64Array(...a_args);
	}
}

// static field
Object.assign(Float64ArrayS.prototype, {
	[sharing.$_SHAREABLE]: 1,
});

// const shared_array_buffer = (nt_buffer) => {
// 	let [s_key, db_array] = shm.create(nt_buffer);
// 	console.log('created shared buffer with key: ',s_key);
// 	return Object.assign(db_array.buffer, {
// 		[$_SHAREABLE]: 1,
// 		key: s_key,
// 	});
// };

const ArrayBufferS = nt_buffer => shmmap.create(nt_buffer);


// globals
module.exports = {
	exports: {
		ArrayBufferS: ArrayBufferS,
		ArrayBufferT: ArrayBufferS,
		Int8ArrayS: Int8ArrayS,
		Int8ArrayT: Int8ArrayS,
		Uint8ArrayS: Uint8ArrayS,
		Uint8ArrayT: Uint8ArrayS,
		Uint8ClampedArrayS: Uint8ClampedArrayS,
		Uint8ClampedArrayT: Uint8ClampedArrayS,
		Int16ArrayS: Int16ArrayS,
		Int16ArrayT: Int16ArrayS,
		Uint16ArrayS: Uint16ArrayS,
		Uint16ArrayT: Uint16ArrayS,
		Int32ArrayS: Int32ArrayS,
		Int32ArrayT: Int32ArrayS,
		Uint32ArrayS: Uint32ArrayS,
		Uint32ArrayT: Uint32ArrayS,
		Float32ArrayS: Float32ArrayS,
		Float32ArrayT: Float32ArrayS,
		Float64ArrayS: Float64ArrayS,
		Float64ArrayT: Float64ArrayS,
	},
};
